/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 rabbit.glb 
*/

import React, { useEffect, useRef } from 'react'
import * as Three from 'three'
import { useFrame } from '@react-three/fiber'
import { useGLTF, useAnimations, useKeyboardControls } from '@react-three/drei'
import { useRabbitAnimations } from '../contexts/RabbitAnimationsContext.jsx'

const Rabbit = (props) => {
  const group = useRef()
  const rabbit = useRef()
  const { nodes, materials, animations } = useGLTF('./models/rabbit.glb')
  const { setAnimationNames, animationIndex } = useRabbitAnimations()
  const { actions, names } = useAnimations(animations, group)
  const [subscribeKeys, getKeys] = useKeyboardControls()

  // These were for the RabbitControlInterface. Commenting them out for now.
  // useEffect(() => {
  //   setAnimationNames(names)
  // }, [names]);

  // useEffect(() => {
  //   actions[names[animationIndex]].reset().fadeIn(0.5).play()
  //   return () => {
  //     actions[names[animationIndex]].fadeOut(0.5)
  //   }
  // }, [animationIndex, actions, names]);

  let forwardRotation = null
  let targetBackwardRotation = null
  useFrame((state, delta) => {
    // Init forward rotation and target backward rotation
    if (forwardRotation === null) forwardRotation = group.current.rotation.y
    if (targetBackwardRotation === null) targetBackwardRotation = forwardRotation - Math.PI

    const keys = getKeys()

    // Reset currentRotation to an equivalent that is between -2*PI and 2*PI
    if (group.current.rotation.y > 2*Math.PI) group.current.rotation.y -= 2*Math.PI
    if (group.current.rotation.y < -2*Math.PI) group.current.rotation.y += 2*Math.PI

    const currentRotation = group.current.rotation.y

    function forward() {
      rabbit.current.position.z += Math.cos(currentRotation)*0.1
      rabbit.current.position.x += Math.sin(currentRotation)*0.1
    }

    if (keys.forward) {
      // Move the rabbit forward relative to its current rotation
      forward()
      forwardRotation = currentRotation
      
      // Set and normalize the target backward rotation
      targetBackwardRotation = forwardRotation - Math.PI
      if (targetBackwardRotation > 2*Math.PI) targetBackwardRotation -= 2*Math.PI
      if (targetBackwardRotation < -2*Math.PI) targetBackwardRotation += 2*Math.PI
    }

    if (keys.backward) {
      // Rotate until the rotation is 180 degrees from the forward rotation
      if (currentRotation >= targetBackwardRotation) {
        group.current.rotation.y -= (0.01*Math.PI*2)
      }
      
      // TODO Repeat the backwards movement after the backwards key has been released

      forward()
    }

    if (keys.left) group.current.rotation.y += (0.005*Math.PI*2)
    if (keys.right) group.current.rotation.y -= (0.005*Math.PI*2)

    if(keys.forward || keys.backward || keys.left || keys.right) {
      actions["walk/jump"].fadeOut(1)
    } else {
      actions["walk/jump"].reset().fadeIn(0.5).play()
    }

    /**
     * Camera
     * NOTE This really shouldn't be here. TODO Refactor to a separate component.
     */
    const cameraPosition = new Three.Vector3()
    cameraPosition.x = rabbit.current.position.x + 3// + Math.sin(currentRotation)*0.1
    cameraPosition.z = rabbit.current.position.z// + Math.cos(currentRotation)*0.1
    cameraPosition.y = rabbit.current.position.y// + 1

    const cameraTarget = new Three.Vector3(0, 0, 0)
    cameraTarget.copy(group.current.position.clone())

    state.camera.position.copy(cameraPosition)
    // state.camera.lookAt(cameraTarget)

    console.log("cameraPosition", cameraPosition)
    console.log("group.current.position", group.current.position)
    console.log("cameraTarget", cameraTarget)

  })

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="metarig" rotation={[0.015, 0, 0]} scale={4.716}>
          <primitive object={nodes.pelvisC} />
          <primitive object={nodes.control_frontl} />
          <primitive object={nodes.pole_target_frontl} />
          <primitive object={nodes.control_frontr} />
          <primitive object={nodes.pole_target_frontr} />
          <primitive object={nodes.control_backl} />
          <primitive object={nodes.pole_backl} />
          <primitive object={nodes.control_backr} />
          <primitive object={nodes.pole_backr} />
          <group name="rabbit" ref={rabbit}>
            <skinnedMesh name="Plane" geometry={nodes.Plane.geometry} material={materials.brown} skeleton={nodes.Plane.skeleton} />
            <skinnedMesh name="Plane_1" geometry={nodes.Plane_1.geometry} material={materials.white} skeleton={nodes.Plane_1.skeleton} />
            <skinnedMesh name="Plane_2" geometry={nodes.Plane_2.geometry} material={materials.black} skeleton={nodes.Plane_2.skeleton} />
          </group>
        </group>
      </group>
    </group>
  )
}

export default Rabbit

useGLTF.preload('./models/rabbit.glb')
